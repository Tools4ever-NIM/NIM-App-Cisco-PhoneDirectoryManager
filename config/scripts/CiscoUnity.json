{"name":"CiscoUnity","studio_file_name":"","typescript":"const readOnly = false\nimport { nim } from \"./nim\";\n\n// #region Configuration\n  type Config = {\n      systemname_AD: String;\n      systemname_CUCM: String;\n      systemname_Unity: String;\n      parkedmailbox_ExtensionUpper: number;\n      parkedmailbox_ExtensionLower: number;\n      ldap_enabled: Boolean;\n      add_smtp: Boolean;\n      add_unifiedmessaging: Boolean;\n      umExternalServiceId: String;\n  }\n\n// #region Private Functions\n  /**\n   * Retrieves variables for app\n   * @returns List of variables\n   */\n  async function getAppVariables(): Promise<Config> {\n    return {\n      systemname_AD: await nim.variableGet('Cisco_SystemName_AD'),\n      systemname_CUCM : await nim.variableGet('Cisco_SystemName_CUCM'),\n      systemname_Unity : await nim.variableGet('Cisco_SystemName_Unity'),\n      parkedmailbox_ExtensionUpper : Number(await nim.variableGet('Cisco_ParkingExtensionUpper')),\n      parkedmailbox_ExtensionLower : Number(await nim.variableGet('Cisco_ParkingExtensionLower')),\n      ldap_enabled : Boolean(await nim.variableGet('Cisco_EnableLdap')),\n      add_smtp : Boolean(await nim.variableGet('Cisco_AddSmtp')),\n      add_unifiedmessaging : Boolean(await nim.variableGet('Cisco_AddUM')),\n      umExternalServiceId : await nim.variableGet('Cisco_UMExternalServiceId')\n    }\n  }\n\n  /**\n   * Retrieves the current associated devices for the owner specified\n   * @param {string} OwnerId - The unique identifier of the owner whose devices are to be fetched.\n   * @returns List of associated devices\n   */\n  async function getOwnerAssociatedDevices(OwnerId: string) {\n    return await nim.filterExecute(\n      \"App_Cisco_Script_GetCUCMUserAssociatedDevices\",\n      { UserId: OwnerId }\n    )\n  }\n\n  /**\n   * Obtains a list of associated devices for the owner and removes them\n   * @param {string} OwnerId - The unique identifier of the owner whose devices are removed\n   */\n  async function removeOwnerDevices(OwnerId: string,systemname_CUCM: any) {\n    const devices = await getOwnerAssociatedDevices(OwnerId)\n\n    if (devices && devices?.length > 0) {\n      nim.logInfo(\n        `Owner [${OwnerId}] has ${devices?.length} Devices`\n      )\n\n      // Loop over each Devices\n      for (const device of devices) {\n        nim.logInfo(`Device Name - [${device.name}]`)\n\n        // Skip Physical Phones\n        //if (device.name.startsWith(\"SEP\")) {\n          nim.logInfo(`Remove Device [${device.name}] - PKID [${device.pkid}]`)\n          if(!readOnly) {\n            await nim.targetSystemFunctionRun(systemname_CUCM, 'EndUserDeviceMapsDelete',{ pkid: device.pkid })\n          }\n        //} else {\n        //  nim.logInfo(`Skipping Device Removal [${device.name}] - PKID [${device.pkid}]`)\n        //}\n      }\n    } else {\n      nim.logInfo(`No devices found for owner [${OwnerId}]`)\n    }\n  }\n  \n  /**\n   * Retrieves AD User Account for specified sAMAccountName\n   * @param {string} sAMAccountName - sAMAccountName of user to return\n   * @param {boolean} ignoreError - If True, ignore errors\n   * @returns AD User Account\n   */\n  async function getADUser(sAMAccountName: string, ignoreError?: boolean) {\n    const adUser = await nim.filterExecute(\"App_Cisco_Script_GetADUser\", {\n      sAMAccountName: sAMAccountName,\n    })\n    \n    if (adUser && adUser.length == 1) {\n      nim.logInfo(`Found AD user [${adUser[0].objectGUID}]`)\n      return adUser[0]\n    } else if (adUser && adUser.length > 1 && !ignoreError) {\n      nim.logError(`Found multiple accounts for [${sAMAccountName}]`)\n      throw new RangeError(`Found multiple accounts for [${sAMAccountName}]`)\n    }\n\n    if(!ignoreError) {\n      nim.logError(`Cannot find AD user for [${sAMAccountName}]`)\n      throw new ReferenceError(`Cannot find AD user for [${sAMAccountName}]`)\n    }\n\n    return null\n  }\n\n  /**\n   * Retrieves Building Details for specified Building ID\n   * @param {number} BuildingID - Building ID to retrieve\n   * @returns Building Details\n   */\n  async function getBuilding(BuildingID: number) {\n    const Building = await nim.filterExecute(\"App_Cisco_Script_GetBuilding\", {\n      BuildingID: BuildingID,\n    })\n    \n    if (Building && Building.length == 1) {\n      nim.logInfo(`Found Building [${Building[0].BuildingID}]`)\n      return Building[0]\n    } else if (Building && Building.length > 1) {\n      nim.logError(`Found multiple buildings for [${BuildingID}]`)\n      throw new RangeError(`Found multiple buildings for [${BuildingID}]`)\n    }\n\n    return null\n  }\n\n  /**\n   * Retrieves Phone Templates for specified Building ID\n   * @param {number} BuildingID - Building ID to retrieve\n   * @returns Phone Templates\n   */\n  async function getPhoneTemplates(BuildingID: number) {\n    const PhoneTemplates = await nim.filterExecute(\"App_Cisco_Script_GetPhoneTemplates\", {\n      BuildingID: BuildingID,\n    })\n    \n    if (PhoneTemplates && PhoneTemplates.length > 0) {\n      nim.logInfo(`Found Phone Templates for Building [${PhoneTemplates[0].BuildingID}]`)\n      return PhoneTemplates\n    }\n\n    throw new Error(`Failed to retrieve Phone Templates for Building [${BuildingID}]`)\n  }\n\n  /**\n   * Retrieves Universal Device Template\n   * @param {string} UUID - Universal Device Template to retrieve\n   * @returns Universal Device Template details\n   */\n  async function getUniversalDeviceTemplate(UUID: string) {\n    const Templates = await nim.filterExecute(\"App_Cisco_Script_GetCUCMUniversalTemplate\", {\n      UUID: UUID,\n    })\n    \n    if (Templates && Templates.length == 1) {\n      nim.logInfo(`Found Universal Device Template [${Templates[0].uuid}]`)\n      return Templates[0]\n    } else if (Templates && Templates.length > 1) {\n      nim.logError(`Found multiple universal device templates for [${UUID}]`)\n      throw new RangeError(`Found multiple universal device templates for [${UUID}]`)\n    }\n\n    throw new Error(`Failed to retrieve universal device template for [${UUID}]`)\n  }\n\n  /**\n   * Retrieves Product\n   * @param {string} Enum - Product Enum to retrieve\n   * @returns Product details\n   */\n  async function getProduct(Enum: string) {\n    const Products = await nim.filterExecute(\"App_Cisco_Script_GetCUCMProduct\", {\n      Enum: Enum,\n    })\n    \n    if (Products && Products.length == 1) {\n      nim.logInfo(`Found Product [${Products[0].enum}]`)\n      return Products[0]\n    } else if (Products && Products.length > 1) {\n      nim.logError(`Found product for [${Enum}]`)\n      throw new RangeError(`Found products for [${Enum}]`)\n    }\n\n    throw new Error(`Failed to get products for [${Enum}]`)\n  }\n\n  /**\n     * Retrieves Unity User Account for specified alias\n     * @param {string} alias - Alisa used to search for user \n     * @param {boolean} ignoreError - If True, ignore errors\n     * @returns Unity User Account\n     */\n  async function getUnityUser(alias: string, ignoreError: boolean) {\n    let unityUser = await nim.filterExecute(\"App_Cisco_Script_GetUnityUser\", {\n      Alias: alias\n    })\n\n    if (unityUser && unityUser.length == 1) {\n      nim.logInfo(`Found Unity user [${unityUser[0].ObjectId}]`)\n      return unityUser[0]\n    } else if (unityUser && unityUser.length > 1 && !ignoreError) {\n      nim.logError(`Found multiple accounts for alias [${alias}]`)\n      throw new RangeError(`Found multiple accounts for extension [${alias}]`)\n    }\n\n    if(!ignoreError) {\n      nim.logError(`Cannot find Unity user for alias [${alias}]`)\n      throw new ReferenceError(`Cannot find Unity user for alias [${alias}]`)\n    }\n\n    return null\n  }\n\n  /**\n     * Retrieves Unity User Account for specified extension\n     * @param {string} Extension - Extension used to search for user \n     * @returns Unity User Account\n     */\n  async function getUnityUserByExtension(Extension: string) {\n    const unitUser = await nim.filterExecute(\"App_Cisco_Script_GetUnityUserByExtension\", {\n      DtmfAccessId: Extension\n    })\n\n    if (unitUser && unitUser.length == 1) {\n      nim.logInfo(`Found Unity user [${unitUser[0].ObjectId}]`)\n      return unitUser[0]\n    } else if (unitUser && unitUser.length > 1) {\n      nim.logError(`Found multiple accounts for extension [${Extension}]`)\n      throw new RangeError(`Found multiple accounts for extension [${Extension}]`)\n    }\n\n    nim.logError(`Cannot find Unity user for extension [${Extension}]`)\n    throw new ReferenceError(`Cannot find Unity user for extension [${Extension}]`)\n  }\n\n  /**\n     * Checks to see if extension is already being assigned\n     * @param {string} Extension - Extension used to search for user \n     * @returns {boolean} - True, if assigned\n     */\n  async function checkExtensionAssigned(Extension: string) {\n    const unitUser = await nim.filterExecute(\"App_Cisco_Script_GetUnityUserByExtension\", {\n      DtmfAccessId: Extension\n    })\n\n    return !!(unitUser && unitUser.length > 0)\n  }\n\n  /**\n   * Retrieves specified Phone Line\n   * @param {string} UUID - The unique identifier of phone line\n   * @returns Phone Line\n   */\n  async function getCUCMPhoneLine(UUID: string) {\n    const PhoneLine = await nim.filterExecute(\n      \"App_Cisco_Script_GetCUCMPhoneLine\",\n      { UUID: UUID }\n    )\n\n    if (PhoneLine && PhoneLine.length == 1) {\n      nim.logInfo(`Found CUCM Line [${PhoneLine[0].uuid}]`)\n      return PhoneLine[0]\n    } else if (PhoneLine && PhoneLine.length > 1) {\n      nim.logError(`Found multiple CUCM Lines for [${UUID}]`)\n      throw new RangeError(`Found multiple CUCM Phone Lines for [${UUID}]`)\n    }\n\n    nim.logError(`Cannot find CUCM Line for [${UUID}]`)\n    throw new ReferenceError(`Cannot find CUCM Line for [${UUID}]`)\n  }\n\n  /**\n   * Retrieves specified Phone \n   * @param {string} UUID - The unique identifier of phone\n   * @returns Phone\n   */\n  async function getCUCMPhone(UUID: string) {\n    const phone = await nim.filterExecute(\"App_Cisco_Script_GetCUCMPhone\", {\n      UUID: UUID,\n    })\n\n    if (phone && phone.length == 1) {\n      nim.logInfo(`Found CUCM Phone [${phone[0].uuid}]`)\n      return phone[0]\n    } else if (phone && phone.length > 1) {\n      nim.logError(`Found multiple CUCM Phone for [${UUID}]`)\n      throw new RangeError(`Found multiple CUCM Phone for [${UUID}]`)\n    }\n    nim.logError(`Cannot find CUCM Phone for [${UUID}]`)\n    throw new ReferenceError(`Cannot find CUCM Phone for [${UUID}]`)\n  }\n\n  /**\n * Generates a unique random number within a specified range that's not already in a given array.\n * \n * @param {number} upper - The upper bound of the random number range.\n * @param {number} lower - The lower bound of the random number range.\n * @param {string[]} existingArray - An array of numbers to check against for uniqueness.\n * @return {string} A unique random number not in the existing array.\n */\n  async function generateUniqueRandom(upper: number, lower: number, existingArray: string[]) {\n    let uniqueRandom\n  \n    do {\n      // Generate a random number between lower and upper (inclusive) and then convert it to a string\n      uniqueRandom = Math.floor(Math.random() * (upper - lower + 1) + lower).toString()\n    } while (existingArray.includes(uniqueRandom)) // Check if the generated number as string is in the array\n    \n    return uniqueRandom // Return the unique random number as a string\n  }\n\n/**\n * Gets current datetime in a specific string format\n * \n * @return {string} returns datetime string in YYYY-MM-DD HH:MM:SS:SSS\n */\n  async function getCurrentTimestamp() {\n    // Get the current date and time\n    const now = new Date()\n\n    // Format each part of the date and time\n    const year = now.getFullYear()\n    const month = (now.getMonth() + 1).toString().padStart(2, '0') // +1 because months are 0-indexed\n    const day = now.getDate().toString().padStart(2, '0')\n    const hours = now.getHours().toString().padStart(2, '0')\n    const minutes = now.getMinutes().toString().padStart(2, '0')\n    const seconds = now.getSeconds().toString().padStart(2, '0')\n    const milliseconds = now.getMilliseconds().toString().padStart(3, '0')\n\n    // Concatenate everything into the final formatted string\n    const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`\n    return formattedDate\n  }\n\n  /**\n * Formats string to delete anything after first match\n * \n * @param {string} text - Source text\n * @param {string} pattern - Pattern to match\n * @return {string} Modified string\n */\n  function deleteAfterFirstMatch(text: string, pattern: string): string {\n    const index = text.indexOf(pattern) // Find the index of the first occurrence of the pattern\n    if (index >= 0) {\n      // If the pattern is found, return the substring up to that index\n      return text.substring(0, index)\n    }\n    // If the pattern is not found, return the original string\n    return text\n  }\n\n// #endregion\n\n// #region NIM Functions\n  /**\n     * Updates Voicemail PIN for User Extension\n     * @param {string} UserId - User for reset\n     * @param {string} NewPIN - New Voicemail PIN\n     */\n  export async function UpdateUserPIN(\n    UserId: string,\n    NewPIN: string\n  ) {\n      nim.logInfo(\"Retrieving app variables\")\n      const appVar = await getAppVariables();\n\n      nim.logInfo(`Retrieving Unity User [${UserId}]`)\n      let UnityUser = await getUnityUser(UserId, false)\n\n      nim.logInfo(`Reseting PIN [${NewPIN}]`)\n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userscredentialpinUpdate',{ UserObjectId: UnityUser?.ObjectId, Credentials: NewPIN })\n      }\n  }\n\n  /**\n     * Updates the Phone Line assignment for user, additionally removing the current owner\n     * @param {string} PhoneLineUUID - The unique identifier of phone line\n     * @param {string} PhoneUUID - The unique identifier of phone\n     * @param {number} BuildingID - BuildingID   \n     * @param {string} ExternalPhoneNumberMask - THe external phone number mask for building\n     * @param {string} CurrentUserId - Current owner username of the phone line\n     * @param {string} NewUserId - New owner username for the phone line\n     * @param {string} NewPhoneLabel - New phone label\n     * @param {string} NewPhoneName - New phone name\n     */\n  export async function UpdateLineAssignment(\n    PhoneLineUUID: string,\n    PhoneUUID: string,\n    BuildingID: number,\n    ExternalPhoneNumberMask: string,\n    //ProvisionSoftPhone: boolean,\n    CurrentUserId: string = '',\n    NewUserId: string,\n    NewPhoneLabel: string,\n    NewPhoneName: string\n  ) {\n    // #region Validation of Resources\n      nim.logInfo(\"Validating resources prior to executing changes\")\n\n      // #region Retrieve app variables\n      nim.logInfo(\"Retrieving app variables\")\n      const appVar = await getAppVariables();\n      // #endregion\n\n      // #region Retrieve Current Owner AD Account\n      nim.logInfo(\"Retrieving current AD user account\")\n        const currentOwnerADUser = await getADUser(CurrentUserId,true)\n      // #endregion\n\n      // #region Retrieve New Owner AD Account\n        nim.logInfo(\"Retrieving new owner AD user account\")\n        const newOwnerADUser = await getADUser(NewUserId)\n      // #endregion\n\n      // #region Retrieve Current Owner CUCM User\n      let currentOwnerCUCMUser = {\n        pkid: ''\n      }\n      const currentOwnerCUCMUserResults = await nim.filterExecute(\n        \"App_Cisco_Script_GetCUCMUser\",\n        { UserId: CurrentUserId })\n\n        if (currentOwnerCUCMUserResults && currentOwnerCUCMUserResults?.length == 1) {\n          currentOwnerCUCMUser.pkid = currentOwnerCUCMUserResults[0].pkid\n        } \n      // #endregion\n\n      // #region Retrieve CUCM Phone Line\n        nim.logInfo(\"Retrieving CUCM Phone Line\")\n        const cucmPhoneLine = await getCUCMPhoneLine(PhoneLineUUID)\n      // #endregion\n\n      // #region Retrieve CUCM Phone\n        nim.logInfo(\"Retrieving CUCM Phone\")\n        const cucmPhone = await getCUCMPhone(PhoneUUID)\n      // #endregion\n\n      // #region Retrieve Building\n        nim.logInfo(\"Retrieving Building\")\n        const Building = await getBuilding(BuildingID)\n      // #endregion\n\n      // #region Retrieve Phone Templates\n        nim.logInfo(\"Retrieving Phone Templates\")\n        const PhoneTemplates = await getPhoneTemplates(BuildingID)\n      // #endregion\n      \n      // #region Get Parked Mailboxes\n        const parkedMailboxes = await nim.filterExecute(\n          \"App_Cisco_Script_GetParkedMailboxes\"\n        )\n\n        let parkedExtensions = parkedMailboxes.map(obj => obj.UnityUserExtension)\n      // #endregion\n\n      nim.logInfo(\"Validation completed\")\n    // #endregion\n\t\n    \n    // #region Previous Owner Devices\n      if(CurrentUserId.length > 0) {    \n          nim.logInfo(\"Check if previous owner has associated devices and remove them\")\n          await removeOwnerDevices(CurrentUserId, appVar.systemname_CUCM)\n      }\n    // #endregion\n\n    // #region New Owner User Account\n      nim.logInfo(\"Check if new owner has CUCM User Account\")\n      let newOwnerCUCMUser = {\n        pkid: ''\n      }\n      const newOwnerCUCMUserResults = await nim.filterExecute(\n        \"App_Cisco_Script_GetCUCMUser\",\n        { UserId: NewUserId })\n      \n\n      if (newOwnerCUCMUserResults && newOwnerCUCMUserResults?.length < 1) {\n        nim.logInfo(`New Owner doesn't exist in CUCM, creating user`)\n        \n\n        if(!readOnly) {\n          let createCUCMUser = await nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'EndUsersCreate',{ firstname: newOwnerADUser?.givenName ?? '', lastname: newOwnerADUser?.sn ?? '', userid: newOwnerADUser?.sAMAccountName ?? '' })\n          newOwnerCUCMUser.pkid = createCUCMUser.pkid\n        }\n      } else {\n        nim.logInfo(`New Owner exists in CUCM, skipping creating user`)\n        newOwnerCUCMUser.pkid = newOwnerCUCMUserResults[0].pkid\n      }\n    // #endregion\n\n    // #region Update Directory Number Description\n      nim.logInfo(\"Updating Directory Number Description\")\n      nim.logInfo(\n        `UUID: [${cucmPhoneLine.dirn_uuid}] - newOwnerUsername: [${NewUserId}] - newAlertingName: [${NewPhoneName} - description: [${NewPhoneLabel}]`\n      )\n      \n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'LinesUpdate',{ uuid: cucmPhoneLine.dirn_uuid, description: NewPhoneLabel, alertingName: NewPhoneName, asciiAlertingName: NewPhoneName})\n      }\n    // #endregion\n\n    // #region Update Device-To-Line Description\n      nim.logInfo(\"Updating Device-To-Line Description\")\n      nim.logInfo(\n        `LineUUID: [${cucmPhoneLine.uuid}] - PhoneUUID: [${cucmPhone.uuid}] - lineIndex: [${cucmPhoneLine.index}] - dirnPattern: [${cucmPhoneLine.dirn_pattern}] - dirnRoutePartitionName: [${cucmPhoneLine.dirn_routePartitionName_text}] - newDescription: [${NewPhoneLabel}] - newName: [${NewPhoneName}] - newExternalCallingMask: [${ExternalPhoneNumberMask}]`\n      )\n      \n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'PhoneLinesUpdate',{ \n                                                                                                      uuid: cucmPhoneLine.uuid, \n                                                                                                      phone_uuid: cucmPhone.uuid,\n                                                                                                      index: cucmPhoneLine.index, \n                                                                                                      dirn_pattern: cucmPhoneLine.dirn_pattern, \n                                                                                                      dirn_routePartitionName_text: cucmPhoneLine.dirn_routePartitionName_text, \n                                                                                                      label: NewPhoneLabel,\n                                                                                                      display: NewPhoneName, \n                                                                                                      e164Mask: ExternalPhoneNumberMask })\n      }\n    // #endregion\n\n    // #region Reassign current extension owner, Update AD User\n      let SkipExtensionOwner = false   \n      nim.logInfo(\"Checking target extension is taken in Unity\")\n\n      if(await checkExtensionAssigned(cucmPhoneLine.dirn_pattern)) {\n        nim.logInfo(`Extension Already assigned [${cucmPhoneLine.dirn_pattern}]`)\n        let CurrentUnityUser = await getUnityUserByExtension(cucmPhoneLine.dirn_pattern)\n\n        if(CurrentUnityUser.Alias.toLowerCase() !== newOwnerADUser?.sAMAccountName.toLowerCase() && CurrentUnityUser.Alias.length > 0) {\n\n          if(!readOnly) {\n            //Get unique advailable parked extension\n            nim.logInfo(\"Generating random parked mailbox extension\")\n            let uniqueParkedExtension = await generateUniqueRandom(appVar.parkedmailbox_ExtensionUpper, appVar.parkedmailbox_ExtensionLower, parkedExtensions)\n            let currentTimestamp = await getCurrentTimestamp()\n\n            nim.logInfo(`Updating parked mailbox Unity user [${CurrentUnityUser.ObjectId}] to extension [${uniqueParkedExtension}]`)\n            let i = 0\n            while(true) {\n              try {\n                await nim.targetSystemFunctionRun(appVar.systemname_Unity,'userUpdate', {\n                  ObjectId: CurrentUnityUser.ObjectId,\n                  DtmfAccessId: uniqueParkedExtension\n                } );\n                break;\n              } catch(e) {\n                i++;\n                if(i < 10) {\n                  parkedExtensions.push(uniqueParkedExtension)\n                  uniqueParkedExtension = await generateUniqueRandom(appVar.parkedmailbox_ExtensionUpper, appVar.parkedmailbox_ExtensionLower, parkedExtensions)\n                } else {\n                  throw new Error(\"Failed to find unique parked extension after 10 attempts\")\n                }\n              }\n            }\n\n            nim.logInfo(\"Storing parked mailbox internally\")\n            await nim.targetSystemFunctionRun('internal', 'Cisco_MailboxParking_create', { UnityUserObjectId: CurrentUnityUser.ObjectId, UnityUserAlias: CurrentUnityUser.Alias, UnityUserExtension: uniqueParkedExtension, DateCreated: currentTimestamp, Deleted: '0'})\n\n            nim.logInfo(\"Updating Current CUCM User Extension\")\n            nim.logInfo(\n              `EndUsersUpdate - pkid: [${currentOwnerCUCMUser.pkid}] - userid: [${CurrentUserId}] - dnorpattern: [none] - routePartitionName: [${cucmPhoneLine.dirn_routePartitionName_text}] - selfService: [${uniqueParkedExtension}]`\n            )\n            await nim.targetSystemFunctionRun(appVar.systemname_CUCM,'EndUsersUpdate',{ pkid:currentOwnerCUCMUser.pkid , userid: CurrentUserId, dnorpattern: '', routePartitionName: cucmPhoneLine.dirn_routePartitionName_text, selfService: uniqueParkedExtension})\n\n            if(currentOwnerADUser && currentOwnerADUser.sAMAccountName.length > 0) {\n              nim.logInfo(\"Updating Current Owner AD User Account\")\n              nim.logInfo(`objectGUID: [${currentOwnerADUser.objectGUID}] - ipPhone: [${uniqueParkedExtension}] - telephoneNumber: [${uniqueParkedExtension}]`)\n              await nim.targetSystemFunctionRun(appVar.systemname_AD, 'UserUpdate',{ objectGUID: currentOwnerADUser?.objectGUID ?? '', ipPhone: uniqueParkedExtension, telephoneNumber: uniqueParkedExtension } )\n            }\n          }\n        } else {\n          SkipExtensionOwner = true\n        }\n      } else { nim.logInfo(`Extension not assigned [${cucmPhoneLine.dirn_pattern}]`)}\n    // #endregion\n\n    // #region New Owner Devices\n      nim.logInfo(\"Check if new owner has associated devices and remove\")\n      await removeOwnerDevices(NewUserId,appVar.systemname_CUCM)\n    // #endregion\n\n    // #region Updae the Phone Owner\n      nim.logInfo(\"Updating Phone Owner\")\n      nim.logInfo(`PhoneUUID: [${cucmPhone.uuid}] - newOwnerUsername: [${NewUserId}]`)\n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'PhonesUpdate',{ uuid: cucmPhone.uuid,ownerUserName_text: NewUserId})\n      }\n    // #endregion\n\n\n    // #region Update New Owner associated devices with all phone names\n      nim.logInfo(\"Update New Owner Associated devices phone names  (remove all existing mapped users)\")\n      const newOwnerDevices = await getOwnerAssociatedDevices(NewUserId);\n        nim.logInfo(`fkdevice: [${cucmPhoneLine.device_pkid}] - fkenduser: [${newOwnerCUCMUser.pkid}] - tkuserassociation: [1] - RemoveAllUsersForDevice: [True]`)\n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'EndUserDeviceMapsCreate',{ fkdevice: cucmPhoneLine.device_pkid, fkenduser: newOwnerCUCMUser.pkid, tkuserassociation: '1', removeAllUsersForDevice: 'True' })\n      }\n      \n    // #endregion\n\n    // #region Update New Owner Primary Extension\n      nim.logInfo(\"Updating New Owner primary extension\")\n      nim.logInfo(\n        `newOwnerUsername: [${NewUserId}] - dirnPattern: [${cucmPhoneLine.dirn_pattern}] - dirnRoutePartitionName: [${cucmPhoneLine.dirn_routePartitionName_text}] - selfService: [${cucmPhoneLine.dirn_pattern}]`\n      )\n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_CUCM,'EndUsersUpdate',{ pkid: newOwnerCUCMUser.pkid ,userid: NewUserId, dnorpattern: cucmPhoneLine.dirn_pattern, routePartitionName: cucmPhoneLine.dirn_routePartitionName_text, selfService: cucmPhoneLine.dirn_pattern})\n      }\n    // #endregion\n\n    // #region Update IPPhone & telephoneNumber for AD User\n      nim.logInfo(\n        `Updating [ipPhone] and [telephoneNumber] for New Owner to [${cucmPhoneLine.dirn_pattern}]`\n      )\n\n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_AD, 'UserUpdate',{ objectGUID: newOwnerADUser?.objectGUID ?? '', ipPhone: cucmPhoneLine.dirn_pattern, telephoneNumber: cucmPhoneLine.dirn_pattern } )\n      }\n    // #endregion\n\n    \n\n    // #region Check New Owner in Unity\n    nim.logInfo(\"Checking if new owner has unity user account\")\n    let newOwnerUnityUser = await getUnityUser(NewUserId,true)\n\n    if(newOwnerUnityUser && newOwnerUnityUser.ObjectId.length < 1) {\n      nim.logInfo(\"Creating Unity user account for new owner\") \n      if(!readOnly) {\n        let LdapType = appVar.ldap_enabled ? '3' : '0'\n\n        let newUnityUser = await nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userCreate',{ \n            Alias: NewUserId, \n            EmailAddress: newOwnerADUser?.mail ?? '', \n            FirstName: newOwnerADUser?.givenName ?? '', \n            LastName: newOwnerADUser?.sn ?? '', \n            LdapType: LdapType,\n            DtmfAccessId: cucmPhoneLine.dirn_pattern, \n            TemplateAlias: Building?.UnityUserTemplateName ?? '', \n            CreateSmtpProxyFromCorp: 'true'\n          } )\n      \n        if((newOwnerADUser?.mail ?? '').length > 0 ) {\n          if(appVar.add_smtp) {\n            try { \n              await nim.targetSystemFunctionRun(appVar.systemname_Unity,'smtpproxyaddressesCreate',{ SmtpAddress: newOwnerADUser?.mail ?? '', ObjectGlobalUserObjectId: newUnityUser.ObjectId })\n            } catch(e) {\n              nim.logWarning(`Updating Unity user smtp address failed: ${e}`)\n            }\n          }\n\n          if(appVar.add_unifiedmessaging) {\n            try {\n              await nim.targetSystemFunctionRun(appVar.systemname_Unity, 'usersexternalserviceaccountsCreate', {\n                ExternalServiceObjectId: appVar.umExternalServiceId,\n                EnableCalendarCapability: 'true',\n                LoginType: '0',\n                EnableMailboxSynchCapability: \"true\",\n                EmailAddressUseCorp: 'true',\n                SubscriberObjectId: newUnityUser?.ObjectId ?? ''\n              })\n            } catch(e) {\n              nim.logWarning(`Updating Unity user external service account failed: ${e}`)\n            }\n          }\n        }\n\n        newOwnerUnityUser = await getUnityUser(NewUserId,false)\n      }\n    } else {\n      nim.logInfo(\"Updating Unity user account for new owner\")\n      if(!readOnly) {\n        \n        if(!SkipExtensionOwner) {\n        nim.logInfo(`Updating Unity user [${newOwnerUnityUser?.ObjectId}] to extension [${cucmPhoneLine.dirn_pattern}]`)\n          await nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userUpdate', {\n            ObjectId: newOwnerUnityUser?.ObjectId ?? '',\n            DtmfAccessId: cucmPhoneLine.dirn_pattern\n          })\n        } else {\n          nim.logInfo('Owner is already properly assigned, skipping assignment')\n        }\n          if((newOwnerADUser?.mail ?? '').length > 0 ) {\n            if(appVar.add_smtp) {\n              try { \n                await nim.targetSystemFunctionRun(appVar.systemname_Unity,'smtpproxyaddressesCreate',{ SmtpAddress: newOwnerADUser?.mail ?? '', ObjectGlobalUserObjectId: newOwnerUnityUser?.ObjectId ?? '' })\n              } catch(e) {\n                nim.logWarning(`Updating Unity user smtp address failed: ${e}`)\n              }\n            }\n\n            if(appVar.add_unifiedmessaging) {\n              try {\n                await nim.targetSystemFunctionRun(appVar.systemname_Unity, 'usersexternalserviceaccountsCreate', {\n                  ExternalServiceObjectId: appVar.umExternalServiceId,\n                  EnableCalendarCapability: 'true',\n                  LoginType: '0',\n                  EnableMailboxSynchCapability: \"true\",\n                  EmailAddressUseCorp: 'true',\n                  SubscriberObjectId: newOwnerUnityUser?.ObjectId ?? ''\n                })\n              } catch(e) {\n                nim.logWarning(`Updating Unity user external service account failed: ${e}`)\n              }\n            }\n        }\n      }\n      \n\n    }\n    // #endregion\n\n    // #region Update New Owner Call Schedule\n      nim.logInfo(\"Updating Unity call schedule for new owner\")\n      nim.logInfo(`ObjectId [${newOwnerUnityUser?.CallHandlerObjectId}] - ScheduleSetObjectId [${Building?.UnityUserCallScheduleObjectId}]`)\n      if(!readOnly) {\n        await nim.targetSystemFunctionRun(appVar.systemname_Unity,'userscallhandlersUpdate', {\n          ScheduleSetObjectId: Building?.UnityUserCallScheduleObjectId ?? '',\n          ObjectId: newOwnerUnityUser?.CallHandlerObjectId ?? ''\n        })\n      }\n    // #endregion\n\n    // #region New Owner Transfer Rules\n      nim.logInfo(\"Checking if User Transfer Rules enabled for Building\")\n      if(Building?.UnityUserTransferRulesEnabled) {\n          nim.logInfo(\"Updating User Transfer Rules\")\n          \n          nim.logInfo(`CallHandlerObjectId [${newOwnerUnityUser?.CallHandlerObjectId}] - Action [${Building?.UnityUserStandardTransferAction}] - Enabled [${Building?.UnityUserStandardTransferEnabled}]`)\n          if(!readOnly) {\n            await nim.targetSystemFunctionRun(appVar.systemname_Unity,'callhandlertransferoptionsUpdate', {\n              TransferOptionType: \"Standard\",\n              Action: Building?.UnityUserStandardTransferAction,\n              Enabled: Building?.UnityUserStandardTransferEnabled,\n              CallHandlerObjectId: newOwnerUnityUser?.CallHandlerObjectId ?? ''\n            })\n          }\n\n          nim.logInfo(`CallHandlerObjectId [${newOwnerUnityUser?.CallHandlerObjectId}] - Action [${Building?.UnityUserClosedTransferAction}] - Enabled [${Building?.UnityUserClosedTransferEnabled}]`)\n          if(!readOnly) {\n            \n            await nim.targetSystemFunctionRun(appVar.systemname_Unity,'callhandlertransferoptionsUpdate', {\n              TransferOptionType: \"Off Hours\",\n              Action: Building?.UnityUserClosedTransferAction,\n              Enabled: Building?.UnityUserClosedTransferEnabled,\n              CallHandlerObjectId: newOwnerUnityUser?.CallHandlerObjectId ?? ''\n            })\n          }\n\n\n          nim.logInfo(`CallHandlerObjectId [${newOwnerUnityUser?.CallHandlerObjectId}] - Action [${Building?.UnityUserAlternateTransferAction}] - Enabled [${Building?.UnityUserAlternateTransferEnabled}]`)\n          if(!readOnly) {\n            await nim.targetSystemFunctionRun(appVar.systemname_Unity,'callhandlertransferoptionsUpdate', {\n              TransferOptionType: \"Alternate\",\n              Action: Building?.UnityUserAlternateTransferAction,\n              Enabled: Building?.UnityUserAlternateTransferEnabled,\n              CallHandlerObjectId: newOwnerUnityUser?.CallHandlerObjectId ?? ''\n            })\n          }\n      }\n    // #endregion\n  }\n// #endregion","javascript":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateLineAssignment = exports.UpdateUserPIN = void 0;\n/// <reference types=\"node\" />\nconst readOnly = false;\n// #region Private Functions\n/**\n * Retrieves variables for app\n * @returns List of variables\n */\nfunction getAppVariables() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            systemname_AD: yield nim.variableGet('Cisco_SystemName_AD'),\n            systemname_CUCM: yield nim.variableGet('Cisco_SystemName_CUCM'),\n            systemname_Unity: yield nim.variableGet('Cisco_SystemName_Unity'),\n            parkedmailbox_ExtensionUpper: Number(yield nim.variableGet('Cisco_ParkingExtensionUpper')),\n            parkedmailbox_ExtensionLower: Number(yield nim.variableGet('Cisco_ParkingExtensionLower')),\n            ldap_enabled: Boolean(yield nim.variableGet('Cisco_EnableLdap')),\n            add_smtp: Boolean(yield nim.variableGet('Cisco_AddSmtp')),\n            add_unifiedmessaging: Boolean(yield nim.variableGet('Cisco_AddUM')),\n            umExternalServiceId: yield nim.variableGet('Cisco_UMExternalServiceId')\n        };\n    });\n}\n/**\n * Retrieves the current associated devices for the owner specified\n * @param {string} OwnerId - The unique identifier of the owner whose devices are to be fetched.\n * @returns List of associated devices\n */\nfunction getOwnerAssociatedDevices(OwnerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield nim.filterExecute(\"App_Cisco_Script_GetCUCMUserAssociatedDevices\", { UserId: OwnerId });\n    });\n}\n/**\n * Obtains a list of associated devices for the owner and removes them\n * @param {string} OwnerId - The unique identifier of the owner whose devices are removed\n */\nfunction removeOwnerDevices(OwnerId, systemname_CUCM) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const devices = yield getOwnerAssociatedDevices(OwnerId);\n        if (devices && (devices === null || devices === void 0 ? void 0 : devices.length) > 0) {\n            nim.logInfo(`Owner [${OwnerId}] has ${devices === null || devices === void 0 ? void 0 : devices.length} Devices`);\n            // Loop over each Devices\n            for (const device of devices) {\n                nim.logInfo(`Device Name - [${device.name}]`);\n                // Skip Physical Phones\n                //if (device.name.startsWith(\"SEP\")) {\n                nim.logInfo(`Remove Device [${device.name}] - PKID [${device.pkid}]`);\n                if (!readOnly) {\n                    yield nim.targetSystemFunctionRun(systemname_CUCM, 'EndUserDeviceMapsDelete', { pkid: device.pkid });\n                }\n                //} else {\n                //  nim.logInfo(`Skipping Device Removal [${device.name}] - PKID [${device.pkid}]`)\n                //}\n            }\n        }\n        else {\n            nim.logInfo(`No devices found for owner [${OwnerId}]`);\n        }\n    });\n}\n/**\n * Retrieves AD User Account for specified sAMAccountName\n * @param {string} sAMAccountName - sAMAccountName of user to return\n * @param {boolean} ignoreError - If True, ignore errors\n * @returns AD User Account\n */\nfunction getADUser(sAMAccountName, ignoreError) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const adUser = yield nim.filterExecute(\"App_Cisco_Script_GetADUser\", {\n            sAMAccountName: sAMAccountName,\n        });\n        if (adUser && adUser.length == 1) {\n            nim.logInfo(`Found AD user [${adUser[0].objectGUID}]`);\n            return adUser[0];\n        }\n        else if (adUser && adUser.length > 1 && !ignoreError) {\n            nim.logError(`Found multiple accounts for [${sAMAccountName}]`);\n            throw new RangeError(`Found multiple accounts for [${sAMAccountName}]`);\n        }\n        if (!ignoreError) {\n            nim.logError(`Cannot find AD user for [${sAMAccountName}]`);\n            throw new ReferenceError(`Cannot find AD user for [${sAMAccountName}]`);\n        }\n        return null;\n    });\n}\n/**\n * Retrieves Building Details for specified Building ID\n * @param {number} BuildingID - Building ID to retrieve\n * @returns Building Details\n */\nfunction getBuilding(BuildingID) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const Building = yield nim.filterExecute(\"App_Cisco_Script_GetBuilding\", {\n            BuildingID: BuildingID,\n        });\n        if (Building && Building.length == 1) {\n            nim.logInfo(`Found Building [${Building[0].BuildingID}]`);\n            return Building[0];\n        }\n        else if (Building && Building.length > 1) {\n            nim.logError(`Found multiple buildings for [${BuildingID}]`);\n            throw new RangeError(`Found multiple buildings for [${BuildingID}]`);\n        }\n        return null;\n    });\n}\n/**\n * Retrieves Phone Templates for specified Building ID\n * @param {number} BuildingID - Building ID to retrieve\n * @returns Phone Templates\n */\nfunction getPhoneTemplates(BuildingID) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const PhoneTemplates = yield nim.filterExecute(\"App_Cisco_Script_GetPhoneTemplates\", {\n            BuildingID: BuildingID,\n        });\n        if (PhoneTemplates && PhoneTemplates.length > 0) {\n            nim.logInfo(`Found Phone Templates for Building [${PhoneTemplates[0].BuildingID}]`);\n            return PhoneTemplates;\n        }\n        throw new Error(`Failed to retrieve Phone Templates for Building [${BuildingID}]`);\n    });\n}\n/**\n * Retrieves Universal Device Template\n * @param {string} UUID - Universal Device Template to retrieve\n * @returns Universal Device Template details\n */\nfunction getUniversalDeviceTemplate(UUID) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const Templates = yield nim.filterExecute(\"App_Cisco_Script_GetCUCMUniversalTemplate\", {\n            UUID: UUID,\n        });\n        if (Templates && Templates.length == 1) {\n            nim.logInfo(`Found Universal Device Template [${Templates[0].uuid}]`);\n            return Templates[0];\n        }\n        else if (Templates && Templates.length > 1) {\n            nim.logError(`Found multiple universal device templates for [${UUID}]`);\n            throw new RangeError(`Found multiple universal device templates for [${UUID}]`);\n        }\n        throw new Error(`Failed to retrieve universal device template for [${UUID}]`);\n    });\n}\n/**\n * Retrieves Product\n * @param {string} Enum - Product Enum to retrieve\n * @returns Product details\n */\nfunction getProduct(Enum) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const Products = yield nim.filterExecute(\"App_Cisco_Script_GetCUCMProduct\", {\n            Enum: Enum,\n        });\n        if (Products && Products.length == 1) {\n            nim.logInfo(`Found Product [${Products[0].enum}]`);\n            return Products[0];\n        }\n        else if (Products && Products.length > 1) {\n            nim.logError(`Found product for [${Enum}]`);\n            throw new RangeError(`Found products for [${Enum}]`);\n        }\n        throw new Error(`Failed to get products for [${Enum}]`);\n    });\n}\n/**\n   * Retrieves Unity User Account for specified alias\n   * @param {string} alias - Alisa used to search for user\n   * @param {boolean} ignoreError - If True, ignore errors\n   * @returns Unity User Account\n   */\nfunction getUnityUser(alias, ignoreError) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let unityUser = yield nim.filterExecute(\"App_Cisco_Script_GetUnityUser\", {\n            Alias: alias\n        });\n        if (unityUser && unityUser.length == 1) {\n            nim.logInfo(`Found Unity user [${unityUser[0].ObjectId}]`);\n            return unityUser[0];\n        }\n        else if (unityUser && unityUser.length > 1 && !ignoreError) {\n            nim.logError(`Found multiple accounts for alias [${alias}]`);\n            throw new RangeError(`Found multiple accounts for extension [${alias}]`);\n        }\n        if (!ignoreError) {\n            nim.logError(`Cannot find Unity user for alias [${alias}]`);\n            throw new ReferenceError(`Cannot find Unity user for alias [${alias}]`);\n        }\n        return null;\n    });\n}\n/**\n   * Retrieves Unity User Account for specified extension\n   * @param {string} Extension - Extension used to search for user\n   * @returns Unity User Account\n   */\nfunction getUnityUserByExtension(Extension) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const unitUser = yield nim.filterExecute(\"App_Cisco_Script_GetUnityUserByExtension\", {\n            DtmfAccessId: Extension\n        });\n        if (unitUser && unitUser.length == 1) {\n            nim.logInfo(`Found Unity user [${unitUser[0].ObjectId}]`);\n            return unitUser[0];\n        }\n        else if (unitUser && unitUser.length > 1) {\n            nim.logError(`Found multiple accounts for extension [${Extension}]`);\n            throw new RangeError(`Found multiple accounts for extension [${Extension}]`);\n        }\n        nim.logError(`Cannot find Unity user for extension [${Extension}]`);\n        throw new ReferenceError(`Cannot find Unity user for extension [${Extension}]`);\n    });\n}\n/**\n   * Checks to see if extension is already being assigned\n   * @param {string} Extension - Extension used to search for user\n   * @returns {boolean} - True, if assigned\n   */\nfunction checkExtensionAssigned(Extension) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const unitUser = yield nim.filterExecute(\"App_Cisco_Script_GetUnityUserByExtension\", {\n            DtmfAccessId: Extension\n        });\n        return !!(unitUser && unitUser.length > 0);\n    });\n}\n/**\n * Retrieves specified Phone Line\n * @param {string} UUID - The unique identifier of phone line\n * @returns Phone Line\n */\nfunction getCUCMPhoneLine(UUID) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const PhoneLine = yield nim.filterExecute(\"App_Cisco_Script_GetCUCMPhoneLine\", { UUID: UUID });\n        if (PhoneLine && PhoneLine.length == 1) {\n            nim.logInfo(`Found CUCM Line [${PhoneLine[0].uuid}]`);\n            return PhoneLine[0];\n        }\n        else if (PhoneLine && PhoneLine.length > 1) {\n            nim.logError(`Found multiple CUCM Lines for [${UUID}]`);\n            throw new RangeError(`Found multiple CUCM Phone Lines for [${UUID}]`);\n        }\n        nim.logError(`Cannot find CUCM Line for [${UUID}]`);\n        throw new ReferenceError(`Cannot find CUCM Line for [${UUID}]`);\n    });\n}\n/**\n * Retrieves specified Phone\n * @param {string} UUID - The unique identifier of phone\n * @returns Phone\n */\nfunction getCUCMPhone(UUID) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const phone = yield nim.filterExecute(\"App_Cisco_Script_GetCUCMPhone\", {\n            UUID: UUID,\n        });\n        if (phone && phone.length == 1) {\n            nim.logInfo(`Found CUCM Phone [${phone[0].uuid}]`);\n            return phone[0];\n        }\n        else if (phone && phone.length > 1) {\n            nim.logError(`Found multiple CUCM Phone for [${UUID}]`);\n            throw new RangeError(`Found multiple CUCM Phone for [${UUID}]`);\n        }\n        nim.logError(`Cannot find CUCM Phone for [${UUID}]`);\n        throw new ReferenceError(`Cannot find CUCM Phone for [${UUID}]`);\n    });\n}\n/**\n* Generates a unique random number within a specified range that's not already in a given array.\n*\n* @param {number} upper - The upper bound of the random number range.\n* @param {number} lower - The lower bound of the random number range.\n* @param {string[]} existingArray - An array of numbers to check against for uniqueness.\n* @return {string} A unique random number not in the existing array.\n*/\nfunction generateUniqueRandom(upper, lower, existingArray) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let uniqueRandom;\n        do {\n            // Generate a random number between lower and upper (inclusive) and then convert it to a string\n            uniqueRandom = Math.floor(Math.random() * (upper - lower + 1) + lower).toString();\n        } while (existingArray.includes(uniqueRandom)); // Check if the generated number as string is in the array\n        return uniqueRandom; // Return the unique random number as a string\n    });\n}\n/**\n * Gets current datetime in a specific string format\n *\n * @return {string} returns datetime string in YYYY-MM-DD HH:MM:SS:SSS\n */\nfunction getCurrentTimestamp() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Get the current date and time\n        const now = new Date();\n        // Format each part of the date and time\n        const year = now.getFullYear();\n        const month = (now.getMonth() + 1).toString().padStart(2, '0'); // +1 because months are 0-indexed\n        const day = now.getDate().toString().padStart(2, '0');\n        const hours = now.getHours().toString().padStart(2, '0');\n        const minutes = now.getMinutes().toString().padStart(2, '0');\n        const seconds = now.getSeconds().toString().padStart(2, '0');\n        const milliseconds = now.getMilliseconds().toString().padStart(3, '0');\n        // Concatenate everything into the final formatted string\n        const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;\n        return formattedDate;\n    });\n}\n/**\n* Formats string to delete anything after first match\n*\n* @param {string} text - Source text\n* @param {string} pattern - Pattern to match\n* @return {string} Modified string\n*/\nfunction deleteAfterFirstMatch(text, pattern) {\n    const index = text.indexOf(pattern); // Find the index of the first occurrence of the pattern\n    if (index >= 0) {\n        // If the pattern is found, return the substring up to that index\n        return text.substring(0, index);\n    }\n    // If the pattern is not found, return the original string\n    return text;\n}\n// #endregion\n// #region NIM Functions\n/**\n   * Updates Voicemail PIN for User Extension\n   * @param {string} UserId - User for reset\n   * @param {string} NewPIN - New Voicemail PIN\n   */\nfunction UpdateUserPIN(UserId, NewPIN) {\n    return __awaiter(this, void 0, void 0, function* () {\n        nim.logInfo(\"Retrieving app variables\");\n        const appVar = yield getAppVariables();\n        nim.logInfo(`Retrieving Unity User [${UserId}]`);\n        let UnityUser = yield getUnityUser(UserId, false);\n        nim.logInfo(`Reseting PIN [${NewPIN}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userscredentialpinUpdate', { UserObjectId: UnityUser === null || UnityUser === void 0 ? void 0 : UnityUser.ObjectId, Credentials: NewPIN });\n        }\n    });\n}\nexports.UpdateUserPIN = UpdateUserPIN;\n/**\n   * Updates the Phone Line assignment for user, additionally removing the current owner\n   * @param {string} PhoneLineUUID - The unique identifier of phone line\n   * @param {string} PhoneUUID - The unique identifier of phone\n   * @param {number} BuildingID - BuildingID\n   * @param {string} ExternalPhoneNumberMask - THe external phone number mask for building\n   * @param {string} CurrentUserId - Current owner username of the phone line\n   * @param {string} NewUserId - New owner username for the phone line\n   * @param {string} NewPhoneLabel - New phone label\n   * @param {string} NewPhoneName - New phone name\n   */\nfunction UpdateLineAssignment(PhoneLineUUID, PhoneUUID, BuildingID, ExternalPhoneNumberMask, \n//ProvisionSoftPhone: boolean,\nCurrentUserId = '', NewUserId, NewPhoneLabel, NewPhoneName) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n    return __awaiter(this, void 0, void 0, function* () {\n        // #region Validation of Resources\n        nim.logInfo(\"Validating resources prior to executing changes\");\n        // #region Retrieve app variables\n        nim.logInfo(\"Retrieving app variables\");\n        const appVar = yield getAppVariables();\n        // #endregion\n        // #region Retrieve Current Owner AD Account\n        nim.logInfo(\"Retrieving current AD user account\");\n        const currentOwnerADUser = yield getADUser(CurrentUserId, true);\n        // #endregion\n        // #region Retrieve New Owner AD Account\n        nim.logInfo(\"Retrieving new owner AD user account\");\n        const newOwnerADUser = yield getADUser(NewUserId);\n        // #endregion\n        // #region Retrieve Current Owner CUCM User\n        let currentOwnerCUCMUser = {\n            pkid: ''\n        };\n        const currentOwnerCUCMUserResults = yield nim.filterExecute(\"App_Cisco_Script_GetCUCMUser\", { UserId: CurrentUserId });\n        if (currentOwnerCUCMUserResults && (currentOwnerCUCMUserResults === null || currentOwnerCUCMUserResults === void 0 ? void 0 : currentOwnerCUCMUserResults.length) == 1) {\n            currentOwnerCUCMUser.pkid = currentOwnerCUCMUserResults[0].pkid;\n        }\n        // #endregion\n        // #region Retrieve CUCM Phone Line\n        nim.logInfo(\"Retrieving CUCM Phone Line\");\n        const cucmPhoneLine = yield getCUCMPhoneLine(PhoneLineUUID);\n        // #endregion\n        // #region Retrieve CUCM Phone\n        nim.logInfo(\"Retrieving CUCM Phone\");\n        const cucmPhone = yield getCUCMPhone(PhoneUUID);\n        // #endregion\n        // #region Retrieve Building\n        nim.logInfo(\"Retrieving Building\");\n        const Building = yield getBuilding(BuildingID);\n        // #endregion\n        // #region Retrieve Phone Templates\n        nim.logInfo(\"Retrieving Phone Templates\");\n        const PhoneTemplates = yield getPhoneTemplates(BuildingID);\n        // #endregion\n        // #region Get Parked Mailboxes\n        const parkedMailboxes = yield nim.filterExecute(\"App_Cisco_Script_GetParkedMailboxes\");\n        let parkedExtensions = parkedMailboxes.map(obj => obj.UnityUserExtension);\n        // #endregion\n        nim.logInfo(\"Validation completed\");\n        // #endregion\n        // #region Previous Owner Devices\n        if (CurrentUserId.length > 0) {\n            nim.logInfo(\"Check if previous owner has associated devices and remove them\");\n            yield removeOwnerDevices(CurrentUserId, appVar.systemname_CUCM);\n        }\n        // #endregion\n        // #region New Owner User Account\n        nim.logInfo(\"Check if new owner has CUCM User Account\");\n        let newOwnerCUCMUser = {\n            pkid: ''\n        };\n        const newOwnerCUCMUserResults = yield nim.filterExecute(\"App_Cisco_Script_GetCUCMUser\", { UserId: NewUserId });\n        if (newOwnerCUCMUserResults && (newOwnerCUCMUserResults === null || newOwnerCUCMUserResults === void 0 ? void 0 : newOwnerCUCMUserResults.length) < 1) {\n            nim.logInfo(`New Owner doesn't exist in CUCM, creating user`);\n            if (!readOnly) {\n                let createCUCMUser = yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'EndUsersCreate', { firstname: (_a = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.givenName) !== null && _a !== void 0 ? _a : '', lastname: (_b = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.sn) !== null && _b !== void 0 ? _b : '', userid: (_c = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.sAMAccountName) !== null && _c !== void 0 ? _c : '' });\n                newOwnerCUCMUser.pkid = createCUCMUser.pkid;\n            }\n        }\n        else {\n            nim.logInfo(`New Owner exists in CUCM, skipping creating user`);\n            newOwnerCUCMUser.pkid = newOwnerCUCMUserResults[0].pkid;\n        }\n        // #endregion\n        // #region Update Directory Number Description\n        nim.logInfo(\"Updating Directory Number Description\");\n        nim.logInfo(`UUID: [${cucmPhoneLine.dirn_uuid}] - newOwnerUsername: [${NewUserId}] - newAlertingName: [${NewPhoneName} - description: [${NewPhoneLabel}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'LinesUpdate', { uuid: cucmPhoneLine.dirn_uuid, description: NewPhoneLabel, alertingName: NewPhoneName, asciiAlertingName: NewPhoneName });\n        }\n        // #endregion\n        // #region Update Device-To-Line Description\n        nim.logInfo(\"Updating Device-To-Line Description\");\n        nim.logInfo(`LineUUID: [${cucmPhoneLine.uuid}] - PhoneUUID: [${cucmPhone.uuid}] - lineIndex: [${cucmPhoneLine.index}] - dirnPattern: [${cucmPhoneLine.dirn_pattern}] - dirnRoutePartitionName: [${cucmPhoneLine.dirn_routePartitionName_text}] - newDescription: [${NewPhoneLabel}] - newName: [${NewPhoneName}] - newExternalCallingMask: [${ExternalPhoneNumberMask}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'PhoneLinesUpdate', {\n                uuid: cucmPhoneLine.uuid,\n                phone_uuid: cucmPhone.uuid,\n                index: cucmPhoneLine.index,\n                dirn_pattern: cucmPhoneLine.dirn_pattern,\n                dirn_routePartitionName_text: cucmPhoneLine.dirn_routePartitionName_text,\n                label: NewPhoneLabel,\n                display: NewPhoneName,\n                e164Mask: ExternalPhoneNumberMask\n            });\n        }\n        // #endregion\n        // #region Reassign current extension owner, Update AD User\n        let SkipExtensionOwner = false;\n        nim.logInfo(\"Checking target extension is taken in Unity\");\n        if (yield checkExtensionAssigned(cucmPhoneLine.dirn_pattern)) {\n            nim.logInfo(`Extension Already assigned [${cucmPhoneLine.dirn_pattern}]`);\n            let CurrentUnityUser = yield getUnityUserByExtension(cucmPhoneLine.dirn_pattern);\n            if (CurrentUnityUser.Alias.toLowerCase() !== (newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.sAMAccountName.toLowerCase()) && CurrentUnityUser.Alias.length > 0) {\n                if (!readOnly) {\n                    //Get unique advailable parked extension\n                    nim.logInfo(\"Generating random parked mailbox extension\");\n                    let uniqueParkedExtension = yield generateUniqueRandom(appVar.parkedmailbox_ExtensionUpper, appVar.parkedmailbox_ExtensionLower, parkedExtensions);\n                    let currentTimestamp = yield getCurrentTimestamp();\n                    nim.logInfo(`Updating parked mailbox Unity user [${CurrentUnityUser.ObjectId}] to extension [${uniqueParkedExtension}]`);\n                    let i = 0;\n                    while (true) {\n                        try {\n                            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userUpdate', {\n                                ObjectId: CurrentUnityUser.ObjectId,\n                                DtmfAccessId: uniqueParkedExtension\n                            });\n                            break;\n                        }\n                        catch (e) {\n                            i++;\n                            if (i < 10) {\n                                parkedExtensions.push(uniqueParkedExtension);\n                                uniqueParkedExtension = yield generateUniqueRandom(appVar.parkedmailbox_ExtensionUpper, appVar.parkedmailbox_ExtensionLower, parkedExtensions);\n                            }\n                            else {\n                                throw new Error(\"Failed to find unique parked extension after 10 attempts\");\n                            }\n                        }\n                    }\n                    nim.logInfo(\"Storing parked mailbox internally\");\n                    yield nim.targetSystemFunctionRun('internal', 'Cisco_MailboxParking_create', { UnityUserObjectId: CurrentUnityUser.ObjectId, UnityUserAlias: CurrentUnityUser.Alias, UnityUserExtension: uniqueParkedExtension, DateCreated: currentTimestamp, Deleted: '0' });\n                    nim.logInfo(\"Updating Current CUCM User Extension\");\n                    nim.logInfo(`EndUsersUpdate - pkid: [${currentOwnerCUCMUser.pkid}] - userid: [${CurrentUserId}] - dnorpattern: [none] - routePartitionName: [${cucmPhoneLine.dirn_routePartitionName_text}] - selfService: [${uniqueParkedExtension}]`);\n                    yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'EndUsersUpdate', { pkid: currentOwnerCUCMUser.pkid, userid: CurrentUserId, dnorpattern: '', routePartitionName: cucmPhoneLine.dirn_routePartitionName_text, selfService: uniqueParkedExtension });\n                    if (currentOwnerADUser && currentOwnerADUser.sAMAccountName.length > 0) {\n                        nim.logInfo(\"Updating Current Owner AD User Account\");\n                        nim.logInfo(`objectGUID: [${currentOwnerADUser.objectGUID}] - ipPhone: [${uniqueParkedExtension}] - telephoneNumber: [${uniqueParkedExtension}]`);\n                        yield nim.targetSystemFunctionRun(appVar.systemname_AD, 'UserUpdate', { objectGUID: (_d = currentOwnerADUser === null || currentOwnerADUser === void 0 ? void 0 : currentOwnerADUser.objectGUID) !== null && _d !== void 0 ? _d : '', ipPhone: uniqueParkedExtension, telephoneNumber: uniqueParkedExtension });\n                    }\n                }\n            }\n            else {\n                SkipExtensionOwner = true;\n            }\n        }\n        else {\n            nim.logInfo(`Extension not assigned [${cucmPhoneLine.dirn_pattern}]`);\n        }\n        // #endregion\n        // #region New Owner Devices\n        nim.logInfo(\"Check if new owner has associated devices and remove\");\n        yield removeOwnerDevices(NewUserId, appVar.systemname_CUCM);\n        // #endregion\n        // #region Updae the Phone Owner\n        nim.logInfo(\"Updating Phone Owner\");\n        nim.logInfo(`PhoneUUID: [${cucmPhone.uuid}] - newOwnerUsername: [${NewUserId}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'PhonesUpdate', { uuid: cucmPhone.uuid, ownerUserName_text: NewUserId });\n        }\n        // #endregion\n        // #region Update New Owner associated devices with all phone names\n        nim.logInfo(\"Update New Owner Associated devices phone names  (remove all existing mapped users)\");\n        const newOwnerDevices = yield getOwnerAssociatedDevices(NewUserId);\n        nim.logInfo(`fkdevice: [${cucmPhoneLine.device_pkid}] - fkenduser: [${newOwnerCUCMUser.pkid}] - tkuserassociation: [1] - RemoveAllUsersForDevice: [True]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'EndUserDeviceMapsCreate', { fkdevice: cucmPhoneLine.device_pkid, fkenduser: newOwnerCUCMUser.pkid, tkuserassociation: '1', removeAllUsersForDevice: 'True' });\n        }\n        // #endregion\n        // #region Update New Owner Primary Extension\n        nim.logInfo(\"Updating New Owner primary extension\");\n        nim.logInfo(`newOwnerUsername: [${NewUserId}] - dirnPattern: [${cucmPhoneLine.dirn_pattern}] - dirnRoutePartitionName: [${cucmPhoneLine.dirn_routePartitionName_text}] - selfService: [${cucmPhoneLine.dirn_pattern}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_CUCM, 'EndUsersUpdate', { pkid: newOwnerCUCMUser.pkid, userid: NewUserId, dnorpattern: cucmPhoneLine.dirn_pattern, routePartitionName: cucmPhoneLine.dirn_routePartitionName_text, selfService: cucmPhoneLine.dirn_pattern });\n        }\n        // #endregion\n        // #region Update IPPhone & telephoneNumber for AD User\n        nim.logInfo(`Updating [ipPhone] and [telephoneNumber] for New Owner to [${cucmPhoneLine.dirn_pattern}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_AD, 'UserUpdate', { objectGUID: (_e = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.objectGUID) !== null && _e !== void 0 ? _e : '', ipPhone: cucmPhoneLine.dirn_pattern, telephoneNumber: cucmPhoneLine.dirn_pattern });\n        }\n        // #endregion\n        // #region Check New Owner in Unity\n        nim.logInfo(\"Checking if new owner has unity user account\");\n        let newOwnerUnityUser = yield getUnityUser(NewUserId, true);\n        if (newOwnerUnityUser && newOwnerUnityUser.ObjectId.length < 1) {\n            nim.logInfo(\"Creating Unity user account for new owner\");\n            if (!readOnly) {\n                let LdapType = appVar.ldap_enabled ? '3' : '0';\n                let newUnityUser = yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userCreate', {\n                    Alias: NewUserId,\n                    EmailAddress: (_f = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.mail) !== null && _f !== void 0 ? _f : '',\n                    FirstName: (_g = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.givenName) !== null && _g !== void 0 ? _g : '',\n                    LastName: (_h = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.sn) !== null && _h !== void 0 ? _h : '',\n                    LdapType: LdapType,\n                    DtmfAccessId: cucmPhoneLine.dirn_pattern,\n                    TemplateAlias: (_j = Building === null || Building === void 0 ? void 0 : Building.UnityUserTemplateName) !== null && _j !== void 0 ? _j : '',\n                    CreateSmtpProxyFromCorp: 'true'\n                });\n                if (((_k = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.mail) !== null && _k !== void 0 ? _k : '').length > 0) {\n                    if (appVar.add_smtp) {\n                        try {\n                            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'smtpproxyaddressesCreate', { SmtpAddress: (_l = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.mail) !== null && _l !== void 0 ? _l : '', ObjectGlobalUserObjectId: newUnityUser.ObjectId });\n                        }\n                        catch (e) {\n                            nim.logWarning(`Updating Unity user smtp address failed: ${e}`);\n                        }\n                    }\n                    if (appVar.add_unifiedmessaging) {\n                        try {\n                            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'usersexternalserviceaccountsCreate', {\n                                ExternalServiceObjectId: appVar.umExternalServiceId,\n                                EnableCalendarCapability: 'true',\n                                LoginType: '0',\n                                EnableMailboxSynchCapability: \"true\",\n                                EmailAddressUseCorp: 'true',\n                                SubscriberObjectId: (_m = newUnityUser === null || newUnityUser === void 0 ? void 0 : newUnityUser.ObjectId) !== null && _m !== void 0 ? _m : ''\n                            });\n                        }\n                        catch (e) {\n                            nim.logWarning(`Updating Unity user external service account failed: ${e}`);\n                        }\n                    }\n                }\n                newOwnerUnityUser = yield getUnityUser(NewUserId, false);\n            }\n        }\n        else {\n            nim.logInfo(\"Updating Unity user account for new owner\");\n            if (!readOnly) {\n                if (!SkipExtensionOwner) {\n                    nim.logInfo(`Updating Unity user [${newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.ObjectId}] to extension [${cucmPhoneLine.dirn_pattern}]`);\n                    yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userUpdate', {\n                        ObjectId: (_o = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.ObjectId) !== null && _o !== void 0 ? _o : '',\n                        DtmfAccessId: cucmPhoneLine.dirn_pattern\n                    });\n                }\n                else {\n                    nim.logInfo('Owner is already properly assigned, skipping assignment');\n                }\n                if (((_p = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.mail) !== null && _p !== void 0 ? _p : '').length > 0) {\n                    if (appVar.add_smtp) {\n                        try {\n                            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'smtpproxyaddressesCreate', { SmtpAddress: (_q = newOwnerADUser === null || newOwnerADUser === void 0 ? void 0 : newOwnerADUser.mail) !== null && _q !== void 0 ? _q : '', ObjectGlobalUserObjectId: (_r = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.ObjectId) !== null && _r !== void 0 ? _r : '' });\n                        }\n                        catch (e) {\n                            nim.logWarning(`Updating Unity user smtp address failed: ${e}`);\n                        }\n                    }\n                    if (appVar.add_unifiedmessaging) {\n                        try {\n                            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'usersexternalserviceaccountsCreate', {\n                                ExternalServiceObjectId: appVar.umExternalServiceId,\n                                EnableCalendarCapability: 'true',\n                                LoginType: '0',\n                                EnableMailboxSynchCapability: \"true\",\n                                EmailAddressUseCorp: 'true',\n                                SubscriberObjectId: (_s = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.ObjectId) !== null && _s !== void 0 ? _s : ''\n                            });\n                        }\n                        catch (e) {\n                            nim.logWarning(`Updating Unity user external service account failed: ${e}`);\n                        }\n                    }\n                }\n            }\n        }\n        // #endregion\n        // #region Update New Owner Call Schedule\n        nim.logInfo(\"Updating Unity call schedule for new owner\");\n        nim.logInfo(`ObjectId [${newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId}] - ScheduleSetObjectId [${Building === null || Building === void 0 ? void 0 : Building.UnityUserCallScheduleObjectId}]`);\n        if (!readOnly) {\n            yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'userscallhandlersUpdate', {\n                ScheduleSetObjectId: (_t = Building === null || Building === void 0 ? void 0 : Building.UnityUserCallScheduleObjectId) !== null && _t !== void 0 ? _t : '',\n                ObjectId: (_u = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId) !== null && _u !== void 0 ? _u : ''\n            });\n        }\n        // #endregion\n        // #region New Owner Transfer Rules\n        nim.logInfo(\"Checking if User Transfer Rules enabled for Building\");\n        if (Building === null || Building === void 0 ? void 0 : Building.UnityUserTransferRulesEnabled) {\n            nim.logInfo(\"Updating User Transfer Rules\");\n            nim.logInfo(`CallHandlerObjectId [${newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId}] - Action [${Building === null || Building === void 0 ? void 0 : Building.UnityUserStandardTransferAction}] - Enabled [${Building === null || Building === void 0 ? void 0 : Building.UnityUserStandardTransferEnabled}]`);\n            if (!readOnly) {\n                yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'callhandlertransferoptionsUpdate', {\n                    TransferOptionType: \"Standard\",\n                    Action: Building === null || Building === void 0 ? void 0 : Building.UnityUserStandardTransferAction,\n                    Enabled: Building === null || Building === void 0 ? void 0 : Building.UnityUserStandardTransferEnabled,\n                    CallHandlerObjectId: (_v = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId) !== null && _v !== void 0 ? _v : ''\n                });\n            }\n            nim.logInfo(`CallHandlerObjectId [${newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId}] - Action [${Building === null || Building === void 0 ? void 0 : Building.UnityUserClosedTransferAction}] - Enabled [${Building === null || Building === void 0 ? void 0 : Building.UnityUserClosedTransferEnabled}]`);\n            if (!readOnly) {\n                yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'callhandlertransferoptionsUpdate', {\n                    TransferOptionType: \"Off Hours\",\n                    Action: Building === null || Building === void 0 ? void 0 : Building.UnityUserClosedTransferAction,\n                    Enabled: Building === null || Building === void 0 ? void 0 : Building.UnityUserClosedTransferEnabled,\n                    CallHandlerObjectId: (_w = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId) !== null && _w !== void 0 ? _w : ''\n                });\n            }\n            nim.logInfo(`CallHandlerObjectId [${newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId}] - Action [${Building === null || Building === void 0 ? void 0 : Building.UnityUserAlternateTransferAction}] - Enabled [${Building === null || Building === void 0 ? void 0 : Building.UnityUserAlternateTransferEnabled}]`);\n            if (!readOnly) {\n                yield nim.targetSystemFunctionRun(appVar.systemname_Unity, 'callhandlertransferoptionsUpdate', {\n                    TransferOptionType: \"Alternate\",\n                    Action: Building === null || Building === void 0 ? void 0 : Building.UnityUserAlternateTransferAction,\n                    Enabled: Building === null || Building === void 0 ? void 0 : Building.UnityUserAlternateTransferEnabled,\n                    CallHandlerObjectId: (_x = newOwnerUnityUser === null || newOwnerUnityUser === void 0 ? void 0 : newOwnerUnityUser.CallHandlerObjectId) !== null && _x !== void 0 ? _x : ''\n                });\n            }\n        }\n    });\n}\nexports.UpdateLineAssignment = UpdateLineAssignment;\n// #endregion\n","production_ready":true,"message":"","signatures":[{"name":"UpdateUserPIN","input_args":[{"name":"UserId","type":0},{"name":"NewPIN","type":0}],"output_args":[]},{"name":"UpdateLineAssignment","input_args":[{"name":"PhoneLineUUID","type":0},{"name":"PhoneUUID","type":0},{"name":"BuildingID","type":1},{"name":"ExternalPhoneNumberMask","type":0},{"name":"CurrentUserId","type":0},{"name":"NewUserId","type":0},{"name":"NewPhoneLabel","type":0},{"name":"NewPhoneName","type":0}],"output_args":[]}]}